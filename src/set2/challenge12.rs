use std::collections::HashMap;

use base64::{engine::general_purpose, Engine as _};

use crate::{set1, set2};

// Couldn't figure out a way (except for maybe lazy_static) to
// have a global, random variable since it's not compile-time defined
// This key has been pre-generated by set2::helpers::gen_random_bytes
// function in the true spirit of https://xkcd.com/221/
const CRYPTO_KEY: [u8; 16] = [
    89, 133, 145, 209, 74, 60, 202, 175, 251, 253, 231, 8, 81, 166, 77, 15,
];

pub fn encrypt_ecb_and_append_unknown_string(input: &[u8]) -> Vec<u8> {
    let unknown_string_b64 = "Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK";
    let unknown_string_as_bytes = general_purpose::STANDARD_NO_PAD
        .decode(unknown_string_b64)
        .unwrap();

    // Pad with 5-10 random bytes before, and the same number of
    // (most likely different) random bytes afterwards.
    let mut processed_text = input.to_vec();
    processed_text.extend(unknown_string_as_bytes);

    set2::challenge10::encrypt_ecb(&processed_text, &CRYPTO_KEY)
}

pub fn decrypt_the_unknown_string() -> Vec<u8> {
    // Get the block size of the oracle function's cipher,
    // as well as the size of the secret text
    let mut i = 0;
    let (crypto_block_size, secret_text_length) = loop {
        let curr_size = encrypt_ecb_and_append_unknown_string(&vec![0u8; i]).len();
        // Test next size
        i += 1;
        let next_size = encrypt_ecb_and_append_unknown_string(&vec![0u8; i]).len();

        // If the sizes are different, we've discovered the block size to be
        // the difference between the two sizes. Since next_size will always be
        // greater than curr_size, we take next_size - curr_size
        // i-1 is the size that makes the input have exactly the right length
        if curr_size != next_size {
            break (next_size - curr_size, curr_size - (i - 1));
        }
    };

    // Check that the encrypted string is properly detected as ECB.
    // This means that the oracle function is using ECB.
    assert!(
        set1::challenge8::is_ecb(&encrypt_ecb_and_append_unknown_string(&vec![0x61; 48])) != None
    );

    // We want to extract one byte of the secret text at a time, and we
    // aim to do this by making the oracle "pad" some input with exactly
    // n+1 bytes of the secret, where n is the amount of secret bytes already
    // extracted.
    // This means that for the first byte, we want to send a string with one
    // byte too few, so that the first secret byte is used as the last char in
    // that block. We can then check every possible block to find the matching
    // one, and this gives us our secret byte.
    // For the second, we input a string two bytes too short, since the oracle
    // will then "pad" our string with two bytes - one of which we already have.
    // Once we get to extracting the crypto_block_size+1:th byte, we can no longer
    // rely on checking the first block of the output, as the secret will always
    // overflow to the second block. Thus, we cycle back to one byte too short,
    // and simply start the process over again but with the second output block.
    // Since we have crypto_block_size bytes, making our input one byte too short
    // means we can still reproduce the first two output blocks, save for the last
    // character of the second. Thus, the one block of output we actually want to
    // compare has index n / crypto_block_size.
    let mut secret_text = Vec::<u8>::new();
    for revealed_bytes in 0..secret_text_length {
        let block_to_cmp_idx = revealed_bytes / crypto_block_size;

        // We want this to be revealed_bytes + 1 shorter than
        // the block size, but when we have revealed crypto_block_size blocks,
        // we have to start over at 1. Thus:
        // k shorter than the block => crypto_block_size - k
        // k = current_revealed_blocks + 1 but only from 1..=crypto_block_size
        // Hence, we take k mod (crypto_block_size) (=0..crypto_block_size) + 1
        let n_bytes_short =
            vec![0x61; crypto_block_size - ((revealed_bytes % crypto_block_size) + 1)];

        // Now also "pad" this with all chars we know so far (simulating the oracle)
        // This will always be concruent with - 1 mod crypto_block_size, as we first
        // go to crypto_block_size - (revealed_bytes % crypto_block_size) - 1 bytes
        // and then add revealed_bytes back.
        let mut n_bytes_short_filled = n_bytes_short.clone();
        n_bytes_short_filled.extend(&secret_text);

        // Manually go through every possible last-byte value and save
        // the outputs. Then check which of these matches the value for
        // the one_byte_short input. The match will give us the first
        // byte of unknown_string_as_bytes.
        let mut output_values_for_bytes = HashMap::<u8, Vec<u8>>::new();
        for i in 0..=255 {
            let mut potential_match = n_bytes_short_filled.clone();
            potential_match.push(i);
            output_values_for_bytes
                .insert(i, encrypt_ecb_and_append_unknown_string(&potential_match));
        }

        // Get the "real" output
        let oracle_output = encrypt_ecb_and_append_unknown_string(&n_bytes_short);

        // Compare the real output to all our potential ones.
        // When we find a match, add the key to revealed_bytes
        // We only need to compare the block at index block_to_cmp_idx
        for (k, v) in output_values_for_bytes {
            let our_block = &v
                [block_to_cmp_idx * crypto_block_size..(block_to_cmp_idx + 1) * crypto_block_size];
            let oracle_block = &oracle_output
                [block_to_cmp_idx * crypto_block_size..(block_to_cmp_idx + 1) * crypto_block_size];

            if our_block == oracle_block {
                secret_text.push(k);
            }
        }
    }

    secret_text
}
